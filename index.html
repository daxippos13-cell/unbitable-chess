<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEUS EX CHESS // UNBOUND</title>
    <style>
        :root {
            --bg-color: #050505;
            --board-dark: #2a2a2a;
            --board-light: #a0a0a0;
            --highlight: rgba(0, 255, 242, 0.6);
            --last-move: rgba(255, 0, 85, 0.4);
            --text-color: #00fff2;
            --error-color: #ff0055;
            --piece-color-white: #e0e0e0;
            --piece-color-black: #111;
            --piece-stroke-black: #00fff2;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        h1 { margin-bottom: 5px; text-shadow: 0 0 10px var(--text-color); }

        #game-container {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 5px solid var(--text-color);
            box-shadow: 0 0 20px var(--text-color);
            position: relative;
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 45px;
            cursor: pointer;
            position: relative;
        }

        .white-square { background-color: var(--board-light); color: black; }
        .black-square { background-color: var(--board-dark); color: white; }

        /* ALL OVERLAYS MUST IGNORE CLICKS */
        .piece, .valid-move-marker, .last-move, .highlight {
            pointer-events: none; 
        }

        .piece { z-index: 5; transition: transform 0.1s; }
        .piece.white { color: var(--piece-color-white); text-shadow: 0 0 2px black; }
        .piece.black { color: var(--piece-color-black); text-shadow: 0 0 2px var(--piece-stroke-black); }

        .highlight { background-color: var(--highlight) !important; }
        .last-move { background-color: var(--last-move) !important; }

        .valid-move-marker {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: rgba(0, 255, 242, 0.7);
            border-radius: 50%;
            z-index: 10;
            box-shadow: 0 0 5px #00fff2;
        }

        #status {
            font-size: 1.2rem;
            min-height: 1.5em;
            text-align: center;
            font-weight: bold;
        }

        #notification-area {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            width: 80%;
            align-items: center;
        }

        .notification {
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid var(--error-color);
            color: var(--error-color);
            padding: 10px 20px;
            border-radius: 4px;
            box-shadow: 0 0 15px var(--error-color);
            font-weight: bold;
            text-align: center;
            max-width: 600px;
        }

        #main-menu, #side-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--text-color);
            padding: 40px;
            box-shadow: 0 0 30px var(--text-color);
            z-index: 50;
            position: absolute;
        }
        #side-menu { display: none; }

        button {
            background: transparent;
            border: 1px solid var(--text-color);
            color: var(--text-color);
            padding: 15px 30px;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            font-weight: bold;
            font-size: 1.2rem;
            min-width: 200px;
        }
        button:hover {
            background: var(--text-color);
            color: black;
            box-shadow: 0 0 15px var(--text-color);
        }
        
        .controls { margin-top: 20px; display: flex; gap: 10px; }
        .controls button { font-size: 1rem; padding: 10px 20px; min-width: auto; }

        @media (max-width: 600px) {
            #board { grid-template-columns: repeat(8, 11vw); grid-template-rows: repeat(8, 11vw); }
            .square { width: 11vw; height: 11vw; font-size: 8vw; }
        }
    </style>
</head>
<body>

    <div id="notification-area"></div>

    <div id="main-menu">
        <h1>DEUS EX CHESS</h1>
        <button onclick="selectDifficulty('easy')">EASY</button>
        <button onclick="selectDifficulty('normal')">NORMAL</button>
        <button onclick="selectDifficulty('unbeatable')">UNBEATABLE</button>
    </div>

    <div id="side-menu">
        <h1>CHOOSE SIDE</h1>
        <button onclick="startGame('white')">WHITE</button>
        <button onclick="startGame('black')">BLACK</button>
    </div>
    
    <div id="game-container">
        <div id="status">Waiting...</div>
        <div id="board"></div>
        <div class="controls">
            <button onclick="restartGame()">Restart</button>
        </div>
    </div>

<script>
// --- ERROR TRAP ---
window.onerror = function(msg, url, line, col, error) {
    const area = document.getElementById('notification-area');
    const notif = document.createElement('div');
    notif.className = 'notification';
    notif.innerText = `CRITICAL ERROR: ${msg}`;
    area.appendChild(notif);
    return false;
};

// --- CONFIG ---
const PIECES = { p: '♟', n: '♞', b: '♝', r: '♜', q: '♛', k: '♚', P: '♙', N: '♘', B: '♗', R: '♖', Q: '♕', K: '♔' };
const VALUES = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000, P: 100, N: 320, B: 330, R: 500, Q: 900, K: 20000 };

// PST (Piece-Square Tables) - From white's perspective. Black mirrors these.
const PST = {
    p: [
        [0,  0,  0,  0,  0,  0,  0,  0],
        [50, 50, 50, 50, 50, 50, 50, 50],
        [10, 10, 20, 30, 30, 20, 10, 10],
        [5,  5, 10, 25, 25, 10,  5,  5],
        [0,  0,  0, 20, 20,  0,  0,  0],
        [5, -5,-10,  0,  0,-10, -5,  5],
        [5, 10, 10,-20,-20, 10, 10,  5],
        [0,  0,  0,  0,  0,  0,  0,  0]
    ],
    n: [
        [-50,-40,-30,-30,-30,-30,-40,-50],
        [-40,-20,  0,  0,  0,  0,-20,-40],
        [-30,  0, 10, 15, 15, 10,  0,-30],
        [-30,  5, 15, 20, 20, 15,  5,-30],
        [-30,  0, 15, 20, 20, 15,  0,-30],
        [-30,  5, 10, 15, 15, 10,  5,-30],
        [-40,-20,  0,  5,  5,  0,-20,-40],
        [-50,-40,-30,-30,-30,-30,-40,-50]
    ],
    b: [
        [-20,-10,-10,-10,-10,-10,-10,-20],
        [-10,  0,  0,  0,  0,  0,  0,-10],
        [-10,  0,  5, 10, 10,  5,  0,-10],
        [-10,  5,  5, 10, 10,  5,  5,-10],
        [-10,  0, 10, 10, 10, 10,  0,-10],
        [-10, 10, 10, 10, 10, 10, 10,-10],
        [-10,  5,  0,  0,  0,  0,  5,-10],
        [-20,-10,-10,-10,-10,-10,-10,-20]
    ],
    r: [
        [0,  0,  0,  0,  0,  0,  0,  0],
        [5, 10, 10, 10, 10, 10, 10,  5],
        [-5,  0,  0,  0,  0,  0,  0, -5],
        [-5,  0,  0,  0,  0,  0,  0, -5],
        [-5,  0,  0,  0,  0,  0,  0, -5],
        [-5,  0,  0,  0,  0,  0,  0, -5],
        [-5,  0,  0,  0,  0,  0,  0, -5],
        [0,  0,  0,  5,  5,  0,  0,  0]
    ],
    q: [
        [-20,-10,-10, -5, -5,-10,-10,-20],
        [-10,  0,  0,  0,  0,  0,  0,-10],
        [-10,  0,  5,  5,  5,  5,  0,-10],
        [ -5,  0,  5,  5,  5,  5,  0, -5],
        [  0,  0,  5,  5,  5,  5,  0, -5],
        [-10,  5,  5,  5,  5,  5,  0,-10],
        [-10,  0,  5,  0,  0,  0,  0,-10],
        [-20,-10,-10, -5, -5,-10,-10,-20]
    ],
    k: [
        [-30,-40,-40,-50,-50,-40,-40,-30],
        [-30,-40,-40,-50,-50,-40,-40,-30],
        [-30,-40,-40,-50,-50,-40,-40,-30],
        [-30,-40,-40,-50,-50,-40,-40,-30],
        [-20,-30,-30,-40,-40,-30,-30,-20],
        [-10,-20,-20,-20,-20,-20,-20,-10],
        [20, 20,  0,  0,  0,  0, 20, 20],
        [20, 30, 10,  0,  0, 10, 30, 20]
    ]
};


// --- ENGINE ---
class ChessEngine {
    constructor() {
        this.reset();
    }
    reset() {
        this.board = [
            ['r','n','b','q','k','b','n','r'],
            ['p','p','p','p','p','p','p','p'],
            Array(8).fill(null), Array(8).fill(null), Array(8).fill(null), Array(8).fill(null),
            ['P','P','P','P','P','P','P','P'],
            ['R','N','B','Q','K','B','N','R']
        ];
        this.turn = 'white';
        this.castling = { white: { k: true, q: true }, black: { k: true, q: true } };
        this.enPassant = null;
        this.moveHistory = [];
        this.difficulty = 'normal';
        this.playerColor = 'white';
    }

    setDifficulty(l) { this.difficulty = l; }
    setPlayerColor(c) { this.playerColor = c; }
    onBoard(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; }
    
    getColor(p) { 
        if (!p) return null;
        return p === p.toUpperCase() ? 'white' : 'black';
    }

    generateMoves(r, c, checkCastling = true) {
        const piece = this.board[r][c];
        if (!piece) return [];
        const moves = [];
        const color = this.getColor(piece);
        const type = piece.toLowerCase();
        
        const addMove = (tr, tc) => {
            if (!this.onBoard(tr, tc)) return false;
            const target = this.board[tr][tc];
            if (target === null) {
                moves.push({fr: r, fc: c, tr, tc});
                return true;
            } else if (this.getColor(target) !== color) {
                moves.push({fr: r, fc: c, tr, tc, capture: target});
                return false;
            }
            return false;
        };

        if (type === 'p') {
            const dir = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            // Move forward 1
            if (this.onBoard(r+dir, c) && this.board[r+dir][c] === null) {
                moves.push({fr: r, fc: c, tr: r+dir, tc: c});
                // Move forward 2
                if (r === startRow && this.board[r+dir*2][c] === null) {
                    moves.push({fr: r, fc: c, tr: r+dir*2, tc: c, isDoublePawn: true});
                }
            }
            // Capture
            [[dir, -1], [dir, 1]].forEach(([dr, dc]) => {
                const tr = r+dr, tc = c+dc;
                if (this.onBoard(tr, tc)) {
                    const target = this.board[tr][tc];
                    if (target && this.getColor(target) !== color) {
                         moves.push({fr: r, fc: c, tr: tr, tc: tc, capture: target});
                    }
                    if (this.enPassant && this.enPassant.r === tr && this.enPassant.c === tc) {
                        moves.push({fr: r, fc: c, tr: tr, tc: tc, isEnPassant: true});
                    }
                }
            });
        } else {
            const dirs = {
                n: [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]],
                b: [[-1,-1],[-1,1],[1,-1],[1,1]],
                r: [[-1,0],[1,0],[0,-1],[0,1]],
                q: [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]],
                k: [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]]
            }[type];
            
            dirs.forEach(([dr, dc]) => {
                if (type === 'n' || type === 'k') addMove(r+dr, c+dc);
                else {
                    let i = 1;
                    while (addMove(r + dr*i, c + dc*i)) { i++; }
                }
            });
        }
        
        // Castling
        if (checkCastling && type === 'k' && !this.isCheck(color)) {
            const row = color === 'white' ? 7 : 0;
            const myRook = color === 'white' ? 'R' : 'r';
            // Kingside
            if (this.castling[color].k && this.board[row][7] === myRook && !this.board[row][5] && !this.board[row][6]) {
                if (!this.isSquareAttacked(row, 5, color) && !this.isSquareAttacked(row, 6, color)) {
                    moves.push({fr: r, fc: c, tr: row, tc: 6, isCastling: 'k'});
                }
            }
            // Queenside
            if (this.castling[color].q && this.board[row][0] === myRook && !this.board[row][1] && !this.board[row][2] && !this.board[row][3]) {
                if (!this.isSquareAttacked(row, 3, color)) { // d1/d8 is checked (row, 3)
                    // Note: b1/b8 (row, 1) doesn't need to be safe, only path of king (e1->c1 crosses d1). King lands on c1.
                    // Correct rule: King cannot pass through check. King starts e1(4), crosses d1(3), lands c1(2).
                    // So we check 4 (isCheck does this), 3, and 2.
                    if(!this.isSquareAttacked(row, 2, color)) // Check target square too
                        moves.push({fr: r, fc: c, tr: row, tc: 2, isCastling: 'q'});
                }
            }
        }
        return moves;
    }

    isCheck(color) {
        let kr, kc;
        // Find King
        for(let r=0; r<8; r++) for(let c=0; c<8; c++) if (this.board[r][c] === (color === 'white' ? 'K' : 'k')) { kr = r; kc = c; }
        // If King not found (e.g. testing setups), return true to prevent illegal moves
        if (kr === undefined) return true;
        return this.isSquareAttacked(kr, kc, color);
    }

    isSquareAttacked(r, c, myColor) {
        const enemy = myColor === 'white' ? 'black' : 'white';
        const pDir = myColor === 'white' ? -1 : 1; 
        
        // 1. Pawn attacks from enemy perspective
        // Enemy pawns are at (r - pDir) ? No.
        // If I am white (pDir=-1), enemy black pawns attack me from r-1 (above)? No, black pawns are "above" and attack "down".
        // Black pawns at Row 1 move to Row 2. They attack (r+1, c+/-1).
        // If I am at r, checking if attacked by Black Pawn: Check r-1.
        // Wait. White pawns move Up (Row 6->5). Attack (r-1).
        // Black pawns move Down (Row 1->2). Attack (r+1).
        // So if I am White King at r, Black Pawn at r-1 attacks me.
        
        const enemyPawnDir = myColor === 'white' ? -1 : 1; // If I'm white, look at r-1.
        // Actually: Black Pawn at (r-1, c-1) attacks (r,c).
        
        if (this.onBoard(r+enemyPawnDir, c-1) && this.board[r+enemyPawnDir][c-1] === (enemy==='white'?'P':'p')) return true;
        if (this.onBoard(r+enemyPawnDir, c+1) && this.board[r+enemyPawnDir][c+1] === (enemy==='white'?'P':'p')) return true;
        
        // 2. Knights
        const nMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        for(let m of nMoves) { let tr=r+m[0], tc=c+m[1]; if(this.onBoard(tr,tc) && this.board[tr][tc] === (enemy==='white'?'N':'n')) return true; }
        
        // 3. Sliding
        const straight = [[-1,0],[1,0],[0,-1],[0,1]];
        for(let m of straight) {
            let i=1; while(true){ let tr=r+m[0]*i, tc=c+m[1]*i; if(!this.onBoard(tr,tc)) break; let p=this.board[tr][tc]; if(p){ if(p===(enemy==='white'?'R':'r')||p===(enemy==='white'?'Q':'q')) return true; break; } i++; }
        }
        const diag = [[-1,-1],[-1,1],[1,-1],[1,1]];
        for(let m of diag) {
             let i=1; while(true){ let tr=r+m[0]*i, tc=c+m[1]*i; if(!this.onBoard(tr,tc)) break; let p=this.board[tr][tc]; if(p){ if(p===(enemy==='white'?'B':'b')||p===(enemy==='white'?'Q':'q')) return true; break; } i++; }
        }
        
        // 4. King
        const kMoves = [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]];
        for(let m of kMoves) { let tr=r+m[0], tc=c+m[1]; if(this.onBoard(tr,tc) && this.board[tr][tc] === (enemy==='white'?'K':'k')) return true; }
        
        return false;
    }

    makeMove(move, dryRun = false) {
        // Deep copy castling to prevent history pollution
        const state = { 
            board: JSON.parse(JSON.stringify(this.board)), 
            castling: JSON.parse(JSON.stringify(this.castling)), 
            enPassant: this.enPassant, 
            turn: this.turn, 
            move: move 
        };
        this.moveHistory.push(state);
        
        const p = this.board[move.fr][move.fc];
        
        // Capture logic: Check if capturing a Rook to update opponent castling rights
        const targetPiece = this.board[move.tr][move.tc];
        if (targetPiece === 'R') {
             if (move.tr===7 && move.tc===0) this.castling.white.q=false;
             if (move.tr===7 && move.tc===7) this.castling.white.k=false;
        }
        if (targetPiece === 'r') {
             if (move.tr===0 && move.tc===0) this.castling.black.q=false;
             if (move.tr===0 && move.tc===7) this.castling.black.k=false;
        }

        this.board[move.tr][move.tc] = p;
        this.board[move.fr][move.fc] = null;
        
        // En Passant Capture
        if (move.isEnPassant) {
            this.board[move.tr + (this.turn==='white'?1:-1)][move.tc] = null;
        }
        
        // Castling Move
        if (move.isCastling === 'k') { this.board[move.tr][5] = this.board[move.tr][7]; this.board[move.tr][7] = null; }
        if (move.isCastling === 'q') { this.board[move.tr][3] = this.board[move.tr][0]; this.board[move.tr][0] = null; }
        
        // Promotion
        if (p.toLowerCase() === 'p' && (move.tr===0 || move.tr===7)) {
            this.board[move.tr][move.tc] = this.turn==='white'?'Q':'q'; // Auto-queen
        }

        // Update Castling Rights
        if (p==='K') this.castling.white = {k:false,q:false};
        if (p==='k') this.castling.black = {k:false,q:false};
        if (p==='R') {
             if (move.fr===7 && move.fc===0) this.castling.white.q=false;
             if (move.fr===7 && move.fc===7) this.castling.white.k=false;
        }
        if (p==='r') {
             if (move.fr===0 && move.fc===0) this.castling.black.q=false;
             if (move.fr===0 && move.fc===7) this.castling.black.k=false;
        }
        
        // Update En Passant
        this.enPassant = move.isDoublePawn ? {r:(move.fr+move.tr)/2, c:move.fc} : null;

        // Verify Legal
        if (this.isCheck(this.turn)) {
            this.undoMove();
            return false;
        }
        
        this.turn = this.turn==='white'?'black':'white';
        return true;
    }

    undoMove() {
        if (!this.moveHistory.length) return;
        const s = this.moveHistory.pop();
        this.board = s.board;
        this.castling = s.castling;
        this.enPassant = s.enPassant;
        this.turn = s.turn;
    }

    evaluate() {
        let score = 0;
        for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
            const p = this.board[r][c];
            if(!p) continue;
            
            const type = p.toLowerCase();
            const isWhite = p === p.toUpperCase();
            
            // Material
            let val = VALUES[type];
            
            // PST
            if (PST[type]) {
                // If white, use table as is. If black, mirror row and col?
                // PST is defined for White (Row 0 = Top of board in array? No, usually Rank 8).
                // My board: Row 0 is Top (Black side). Row 7 is Bottom (White side).
                // My PST array: Row 0 is index 0.
                // Standard PST usually Rank 8 to Rank 1? Or Rank 1 to 8?
                // Let's assume my PST maps to Board Indices directly for White.
                // White starts at Row 6/7. So PST[7] is white backrank.
                // If Black, we mirror: Board[r][c] corresponds to PST[7-r][c].
                
                let pstVal = 0;
                if (isWhite) {
                    pstVal = PST[type][r][c];
                } else {
                    pstVal = PST[type][7-r][c]; // Mirror rows for black
                }
                val += pstVal;
            }
            
            score += isWhite ? val : -val;
        }
        return score;
    }

    // Minimax with Alpha-Beta
    // Returns evaluation from White's perspective (Positive = White winning)
    minimax(depth, alpha, beta, isMaximizingPlayer) {
        if (depth === 0) return this.evaluate();
        
        // Generate moves for the CURRENT turn player
        // Note: isMaximizingPlayer tracks if we are maximizing WHITE's score.
        // this.turn tracks who is actually moving on board.
        // If isMax (White), this.turn must be 'white'.
        
        const moves = this.getAllLegalMoves(this.turn);
        
        if (moves.length === 0) {
            if (this.isCheck(this.turn)) return isMaximizingPlayer ? -99999 : 99999; // Checkmate
            return 0; // Stalemate
        }
        
        if (isMaximizingPlayer) { // White
            let maxEval = -Infinity;
            for (let m of moves) {
                this.makeMove(m);
                const evalVal = this.minimax(depth - 1, alpha, beta, false);
                this.undoMove();
                maxEval = Math.max(maxEval, evalVal);
                alpha = Math.max(alpha, evalVal);
                if (beta <= alpha) break;
            }
            return maxEval;
        } else { // Black
            let minEval = Infinity;
            for (let m of moves) {
                this.makeMove(m);
                const evalVal = this.minimax(depth - 1, alpha, beta, true);
                this.undoMove();
                minEval = Math.min(minEval, evalVal);
                beta = Math.min(beta, evalVal);
                if (beta <= alpha) break;
            }
            return minEval;
        }
    }

    getAllLegalMoves(color) {
        let all = [];
        for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
            if(this.getColor(this.board[r][c]) === color) {
                const moves = this.generateMoves(r, c);
                for(let m of moves) {
                    if(this.makeMove(m, true)) { 
                        all.push(m); 
                        this.undoMove(); 
                    }
                }
            }
        }
        return all;
    }

    getBestMove() {
        const depth = this.difficulty === 'easy' ? 1 : (this.difficulty === 'normal' ? 2 : 3);
        const color = this.turn;
        const isWhite = color === 'white';
        const moves = this.getAllLegalMoves(color);
        
        if (!moves.length) return null;
        
        // Sort moves to improve Alpha-Beta (Captures first)
        moves.sort((a, b) => (b.capture ? 10 : 0) - (a.capture ? 10 : 0));

        let bestMove = null;
        let bestVal = isWhite ? -Infinity : Infinity;
        
        // Randomize equals
        // We can just shuffle moves initially?
        moves.sort(() => Math.random() - 0.5); 
        // Re-sort captures to front
        moves.sort((a, b) => (b.capture ? 10 : 0) - (a.capture ? 10 : 0));
        
        for (let m of moves) {
            this.makeMove(m);
            // After I move, it's opponent turn.
            // If I am White (Max), next is Black (Min). So call minimax(..., false).
            const val = this.minimax(depth - 1, -Infinity, Infinity, !isWhite);
            this.undoMove();
            
            if (isWhite) {
                if (val > bestVal) { bestVal = val; bestMove = m; }
            } else {
                if (val < bestVal) { bestVal = val; bestMove = m; }
            }
        }
        return bestMove;
    }
}

// --- UI ---
class ChessUI {
    constructor(game) {
        this.game = game;
        this.el = document.getElementById('board');
        this.selected = null;
        this.moves = [];
        this.setup();
    }

    render() {
        this.el.innerHTML = '';
        const isBlack = this.game.playerColor === 'black';
        
        // If playing Black, we want Row 0 (Black pieces) at the BOTTOM visually?
        // No, if I play Black, I want my pieces (Row 0/1 usually) at the BOTTOM.
        // Wait, in my engine, Black starts at Row 0/1. White at 6/7.
        // So if I play Black, I want Row 0 at Bottom.
        // Standard view (White): Row 0 is TOP. Row 7 is BOTTOM.
        // Black view: Row 7 is TOP. Row 0 is BOTTOM.
        
        for(let vr=0; vr<8; vr++) {
            for(let vc=0; vc<8; vc++) {
                // Visual Row 0 (Top) -> Visual Row 7 (Bottom)
                // If Black View: Visual Row 0 is Logical Row 7.
                // If White View: Visual Row 0 is Logical Row 0.
                
                const r = isBlack ? (7-vr) : vr;
                const c = isBlack ? (7-vc) : vc; // Also flip columns
                
                const sq = document.createElement('div');
                // Color check: (r+c)%2 ?
                // Visual grid pattern must remain checkboard. (vr+vc)%2 is safe.
                sq.className = `square ${(vr+vc)%2===0 ? 'white-square' : 'black-square'}`;
                sq.dataset.r = r;
                sq.dataset.c = c;
                
                const p = this.game.board[r][c];
                if(p) {
                    const pd = document.createElement('div');
                    pd.className = `piece ${this.game.getColor(p)}`;
                    pd.textContent = PIECES[p];
                    sq.appendChild(pd);
                }
                
                // Markers
                const move = this.moves.find(m => m.tr === r && m.tc === c);
                if (move) {
                    const mk = document.createElement('div');
                    mk.className = move.capture ? 'valid-move-marker capture' : 'valid-move-marker';
                    if(move.capture) mk.style.backgroundColor = 'rgba(255, 0, 85, 0.7)'; // Red for capture
                    sq.appendChild(mk);
                }
                
                if (this.selected && this.selected.r === r && this.selected.c === c) sq.classList.add('highlight');
                
                // Last move highlight
                if(this.game.moveHistory.length) {
                    const last = this.game.moveHistory[this.game.moveHistory.length-1].move;
                    if((last.fr===r && last.fc===c) || (last.tr===r && last.tc===c)) sq.classList.add('last-move');
                }

                this.el.appendChild(sq);
            }
        }
        
        document.getElementById('status').textContent = `Turn: ${this.game.turn.toUpperCase()}`;
    }

    setup() {
        this.el.addEventListener('click', e => {
            const sq = e.target.closest('.square');
            if (!sq) return;
            const r = parseInt(sq.dataset.r);
            const c = parseInt(sq.dataset.c);
            
            // Interaction Lock
            if (this.game.turn !== this.game.playerColor) {
                // Allow clicking ONLY if game over? No.
                return;
            }

            const p = this.game.board[r][c];
            
            // Move?
            const move = this.moves.find(m => m.tr === r && m.tc === c);
            if (move) {
                this.game.makeMove(move);
                this.selected = null;
                this.moves = [];
                this.render();
                
                // Checkmate check immediately after move
                if (this.game.isCheck(this.game.turn)) {
                     // Check if mate
                     if(this.game.getAllLegalMoves(this.game.turn).length === 0) {
                         ui.notify("YOU WIN! CHECKMATE.");
                         return;
                     }
                     ui.notify("CHECK!");
                }

                setTimeout(() => this.aiMove(), 100);
                return;
            }

            // Select?
            if (p && this.game.getColor(p) === this.game.playerColor) {
                this.selected = {r, c};
                const legals = this.game.generateMoves(r, c);
                // Filter actual legal moves (no self-check)
                this.moves = legals.filter(m => {
                    const ok = this.game.makeMove(m, true);
                    if(ok) this.game.undoMove();
                    return ok;
                });
                this.render();
                return;
            }
            
            // Deselect with feedback
            if (this.selected) {
                ui.notify("INVALID MOVE");
            }
            this.selected = null;
            this.moves = [];
            this.render();
        });
    }

    aiMove() {
        document.getElementById('status').textContent = "THINKING...";
        // Use timeout to allow UI render
        setTimeout(() => {
            try {
                const m = this.game.getBestMove();
                if (m) {
                    this.game.makeMove(m);
                    this.render();
                    
                    if (this.game.isCheck(this.game.playerColor)) {
                        if(this.game.getAllLegalMoves(this.game.playerColor).length === 0) {
                            ui.notify("GAME OVER. MACHINE WINS.");
                        } else {
                            ui.notify("CHECK!");
                        }
                    } else {
                        // Check stalemate
                        if(this.game.getAllLegalMoves(this.game.playerColor).length === 0) {
                            ui.notify("STALEMATE. DRAW.");
                        }
                    }
                } else {
                    ui.notify("STALEMATE / RESIGN");
                }
            } catch(e) { 
                console.error(e);
                ui.notify("AI ERROR: " + e); 
            }
        }, 50);
    }
    
    notify(msg) {
        const area = document.getElementById('notification-area');
        const d = document.createElement('div');
        d.className = 'notification';
        d.innerText = msg;
        area.appendChild(d);
        setTimeout(() => d.remove(), 3000);
    }
}

const game = new ChessEngine();
const ui = new ChessUI(game);

window.selectDifficulty = (d) => {
    game.difficulty = d;
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('side-menu').style.display = 'flex';
};

window.startGame = (c) => {
    game.reset();
    game.setPlayerColor(c);
    document.getElementById('side-menu').style.display = 'none';
    document.getElementById('game-container').style.display = 'flex';
    ui.render();
    if (c === 'black') setTimeout(() => ui.aiMove(), 500);
};

window.restartGame = () => location.reload();

</script>
</body>
</html>