<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEUS EX CHESS // UNBOUND</title>
    <style>
        :root {
            --bg-color: #050505;
            --board-dark: #2a2a2a;
            --board-light: #a0a0a0;
            --highlight: rgba(0, 255, 242, 0.6);
            --last-move: rgba(255, 0, 85, 0.4);
            --text-color: #00fff2;
            --error-color: #ff0055;
            --piece-color-white: #e0e0e0;
            --piece-color-black: #111;
            --piece-stroke-black: #00fff2; /* Neon glow for black pieces */
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        h1 {
            margin-bottom: 10px;
            text-shadow: 0 0 10px var(--text-color);
            letter-spacing: 2px;
        }

        #game-container {
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 5px solid var(--text-color);
            box-shadow: 0 0 20px var(--text-color);
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 45px;
            cursor: pointer;
            position: relative;
        }

        .white-square { background-color: var(--board-light); color: black; }
        .black-square { background-color: var(--board-dark); color: white; }

        .piece {
            z-index: 2;
            pointer-events: none; /* Let clicks pass to square */
            transition: transform 0.1s;
        }
        
        .piece.white { color: var(--piece-color-white); text-shadow: 0 0 2px black; }
        .piece.black { color: var(--piece-color-black); text-shadow: 0 0 2px var(--piece-stroke-black); }

        .highlight {
            background-color: var(--highlight) !important;
        }

        .last-move {
            background-color: var(--last-move) !important;
        }

        .valid-move-marker {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: rgba(0, 255, 242, 0.5);
            border-radius: 50%;
            pointer-events: none;
        }

        #status {
            font-size: 1.2rem;
            margin-top: 10px;
            min-height: 1.5em;
            text-align: center;
        }

        #notification-area {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .notification {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid var(--error-color);
            color: var(--error-color);
            padding: 15px 30px;
            border-radius: 4px;
            box-shadow: 0 0 15px var(--error-color);
            animation: slideIn 0.3s ease-out;
            font-weight: bold;
            text-transform: uppercase;
        }

        @keyframes slideIn {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* Main Menu Styles */
        #main-menu, #side-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--text-color);
            padding: 40px;
            box-shadow: 0 0 30px var(--text-color);
            z-index: 50;
            position: absolute;
        }
        
        #side-menu { display: none; }

        button {
            background: transparent;
            border: 1px solid var(--text-color);
            color: var(--text-color);
            padding: 15px 30px;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            font-weight: bold;
            font-size: 1.2rem;
            min-width: 200px;
        }

        button:hover {
            background: var(--text-color);
            color: black;
            box-shadow: 0 0 15px var(--text-color);
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        .controls button {
            font-size: 1rem;
            padding: 10px 20px;
            min-width: auto;
        }

        /* Responsive */
        @media (max-width: 600px) {
            #board {
                grid-template-columns: repeat(8, 11vw);
                grid-template-rows: repeat(8, 11vw);
            }
            .square {
                width: 11vw;
                height: 11vw;
                font-size: 8vw;
            }
        }
    </style>
</head>
<body>

    <div id="notification-area"></div>

    <div id="main-menu">
        <h1>DEUS EX CHESS</h1>
        <p>SELECT DIFFICULTY</p>
        <button onclick="selectDifficulty('easy')">EASY</button>
        <button onclick="selectDifficulty('normal')">NORMAL</button>
        <button onclick="selectDifficulty('unbeatable')">UNBEATABLE</button>
    </div>

    <div id="side-menu">
        <h1>CHOOSE SIDE</h1>
        <p>SELECT YOUR ALLEGIANCE</p>
        <button onclick="startGame('white')">WHITE (First Move)</button>
        <button onclick="startGame('black')">BLACK (Second Move)</button>
    </div>
    
    <div id="game-container">
        <h1>DEUS EX CHESS</h1>
        <div id="status">Preparing...</div>
        <div id="board"></div>
        <div class="controls">
            <button onclick="showMenu()">Main Menu</button>
            <button onclick="restartGame()">Reset System</button>
        </div>
    </div>

<script>
/**
 * DEUS EX CHESS ENGINE
 * A self-contained, high-performance chess engine and UI.
 * Pure JS. No dependencies. 
 */

// --- Constants & Config ---
const PIECES = {
    p: '♟', n: '♞', b: '♝', r: '♜', q: '♛', k: '♚',
    P: '♙', N: '♘', B: '♗', R: '♖', Q: '♕', K: '♔'
};

const VALUES = {
    p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000,
    P: 100, N: 320, B: 330, R: 500, Q: 900, K: 20000
};

// PST (Piece-Square Tables) for positional evaluation (Midgame)
const PST = {
    P: [
        [0,  0,  0,  0,  0,  0,  0,  0],
        [50, 50, 50, 50, 50, 50, 50, 50],
        [10, 10, 20, 30, 30, 20, 10, 10],
        [5,  5, 10, 25, 25, 10,  5,  5],
        [0,  0,  0, 20, 20,  0,  0,  0],
        [5, -5,-10,  0,  0,-10, -5,  5],
        [5, 10, 10,-20,-20, 10, 10,  5],
        [0,  0,  0,  0,  0,  0,  0,  0]
    ],
    N: [
        [-50,-40,-30,-30,-30,-30,-40,-50],
        [-40,-20,  0,  0,  0,  0,-20,-40],
        [-30,  0, 10, 15, 15, 10,  0,-30],
        [-30,  5, 15, 20, 20, 15,  5,-30],
        [-30,  0, 15, 20, 20, 15,  0,-30],
        [-30,  5, 10, 15, 15, 10,  5,-30],
        [-40,-20,  0,  5,  5,  0,-20,-40],
        [-50,-40,-30,-30,-30,-30,-40,-50]
    ],
    B: [
        [-20,-10,-10,-10,-10,-10,-10,-20],
        [-10,  0,  0,  0,  0,  0,  0,-10],
        [-10,  0,  5, 10, 10,  5,  0,-10],
        [-10,  5,  5, 10, 10,  5,  5,-10],
        [-10,  0, 10, 10, 10, 10,  0,-10],
        [-10, 10, 10, 10, 10, 10, 10,-10],
        [-10,  5,  0,  0,  0,  0,  5,-10],
        [-20,-10,-10,-10,-10,-10,-10,-20]
    ],
    R: [
        [0,  0,  0,  0,  0,  0,  0,  0],
        [5, 10, 10, 10, 10, 10, 10,  5],
        [-5,  0,  0,  0,  0,  0,  0, -5],
        [-5,  0,  0,  0,  0,  0,  0, -5],
        [-5,  0,  0,  0,  0,  0,  0, -5],
        [-5,  0,  0,  0,  0,  0,  0, -5],
        [-5,  0,  0,  0,  0,  0,  0, -5],
        [0,  0,  0,  5,  5,  0,  0,  0]
    ],
    Q: [
        [-20,-10,-10, -5, -5,-10,-10,-20],
        [-10,  0,  0,  0,  0,  0,  0,-10],
        [-10,  0,  5,  5,  5,  5,  0,-10],
        [-5,  0,  5,  5,  5,  5,  0, -5],
        [0,  0,  5,  5,  5,  5,  0, -5],
        [-10,  5,  5,  5,  5,  5,  0,-10],
        [-10,  0,  5,  0,  0,  0,  0,-10],
        [-20,-10,-10, -5, -5,-10,-10,-20]
    ],
    K: [
        [-30,-40,-40,-50,-50,-40,-40,-30],
        [-30,-40,-40,-50,-50,-40,-40,-30],
        [-30,-40,-40,-50,-50,-40,-40,-30],
        [-30,-40,-40,-50,-50,-40,-40,-30],
        [-20,-30,-30,-40,-40,-30,-30,-20],
        [-10,-20,-20,-20,-20,-20,-20,-10],
        [20, 20,  0,  0,  0,  0, 20, 20],
        [20, 30, 10,  0,  0, 10, 30, 20]
    ]
};

// Mirror PST for Black
function mirrorPST(table) {
    return table.slice().reverse();
}

const PST_BLACK = {
    p: mirrorPST(PST.P), n: mirrorPST(PST.N), b: mirrorPST(PST.B),
    r: mirrorPST(PST.R), q: mirrorPST(PST.Q), k: mirrorPST(PST.K)
};

// --- Game Logic ---

class ChessEngine {
    constructor() {
        this.reset();
    }

    reset() {
        // Simple 8x8 array representation. 
        // Capital = White, Lowercase = Black, null = Empty
        this.board = [
            ['r','n','b','q','k','b','n','r'],
            ['p','p','p','p','p','p','p','p'],
            [null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,null],
            [null,null,null,null,null,null,null,null],
            ['P','P','P','P','P','P','P','P'],
            ['R','N','B','Q','K','B','N','R']
        ];
        this.turn = 'white'; // 'white' or 'black'
        this.castling = {
            white: { k: true, q: true },
            black: { k: true, q: true }
        };
        this.enPassant = null; // Target square {r, c}
        this.halfMoves = 0;
        this.moveHistory = [];
        this.gameOver = false;
        this.difficulty = 'normal';
        this.playerColor = 'white'; // Default
    }

    setDifficulty(level) { this.difficulty = level; }
    setPlayerColor(color) { this.playerColor = color; }

    // Helper: is on board?
    onBoard(r, c) {
        return r >= 0 && r < 8 && c >= 0 && c < 8;
    }

    getPiece(r, c) {
        return this.onBoard(r, c) ? this.board[r][c] : null;
    }

    isWhite(piece) { return piece && piece === piece.toUpperCase(); }
    isBlack(piece) { return piece && piece === piece.toLowerCase(); }
    
    getColor(piece) { 
        if (!piece) return null;
        return this.isWhite(piece) ? 'white' : 'black'; 
    }

    // Generate PSEUDO-legal moves (doesn't check if King is left in check)
    generateMoves(r, c, checkCastling = true) {
        const piece = this.board[r][c];
        if (!piece) return [];
        const moves = [];
        const color = this.getColor(piece);
        const type = piece.toLowerCase();
        
        const directions = {
            n: [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]],
            b: [[-1,-1],[-1,1],[1,-1],[1,1]],
            r: [[-1,0],[1,0],[0,-1],[0,1]],
            q: [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]],
            k: [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]]
        };

        const addMove = (tr, tc) => {
            // Check boundaries
            if (!this.onBoard(tr, tc)) return false; // Stop sliding
            const target = this.board[tr][tc];
            // Capture or Empty
            if (target === null) {
                moves.push({fr: r, fc: c, tr, tc});
                return true; // Continue sliding
            } else if (this.getColor(target) !== color) {
                moves.push({fr: r, fc: c, tr, tc, capture: target});
                return false; // Stop sliding (capture)
            }
            return false; // Stop sliding (blocked by own piece)
        };

        if (type === 'p') {
            const dir = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            
            // Move forward 1
            if (this.onBoard(r+dir, c) && this.board[r+dir][c] === null) {
                moves.push({fr: r, fc: c, tr: r+dir, tc: c});
                // Move forward 2
                if (r === startRow && this.board[r+dir*2][c] === null) {
                    moves.push({fr: r, fc: c, tr: r+dir*2, tc: c, isDoublePawn: true});
                }
            }
            // Captures
            [[dir, -1], [dir, 1]].forEach(([dr, dc]) => {
                if (this.onBoard(r+dr, c+dc)) {
                    const target = this.board[r+dr][c+dc];
                    if (target && this.getColor(target) !== color) {
                        moves.push({fr: r, fc: c, tr: r+dr, tc: c+dc, capture: target});
                    }
                    // En Passant
                    if (this.enPassant && this.enPassant.r === r+dr && this.enPassant.c === c+dc) {
                        moves.push({fr: r, fc: c, tr: r+dr, tc: c+dc, isEnPassant: true});
                    }
                }
            });
        } else if (type === 'n' || type === 'k') {
            directions[type].forEach(([dr, dc]) => addMove(r+dr, c+dc));
        } else {
            // Sliding pieces (b, r, q)
            directions[type].forEach(([dr, dc]) => {
                let i = 1;
                while (addMove(r + dr*i, c + dc*i)) { i++; }
            });
        }

        // Castling (King only)
        if (checkCastling && type === 'k' && !this.isCheck(color)) {
            const row = color === 'white' ? 7 : 0;
            const rights = this.castling[color];
            if (rights.k && this.board[row][5] === null && this.board[row][6] === null) {
                if (!this.isSquareAttacked(row, 5, color) && !this.isSquareAttacked(row, 6, color)) {
                    moves.push({fr: r, fc: c, tr: row, tc: 6, isCastling: 'k'});
                }
            }
            if (rights.q && this.board[row][1] === null && this.board[row][2] === null && this.board[row][3] === null) {
                if (!this.isSquareAttacked(row, 3, color) && !this.isSquareAttacked(row, 2, color)) { // Note: b1/b8 doesn't need to be safe, just c1/d1 and king path
                    moves.push({fr: r, fc: c, tr: row, tc: 2, isCastling: 'q'});
                }
            }
        }

        return moves;
    }

    // Is current player's king in check?
    isCheck(color) {
        // Find King
        let kr, kc;
        for(let r=0; r<8; r++) {
            for(let c=0; c<8; c++) {
                if (this.board[r][c] === (color === 'white' ? 'K' : 'k')) {
                    kr = r; kc = c;
                    break;
                }
            }
        }
        return this.isSquareAttacked(kr, kc, color);
    }

    isSquareAttacked(r, c, myColor) {
        const enemyColor = myColor === 'white' ? 'black' : 'white';
        // Check all enemy pieces to see if they can hit (r,c)
        
        // Pawn attacks
        const pDir = myColor === 'white' ? -1 : 1;
        if (this.onBoard(r+pDir, c-1) && this.board[r+pDir][c-1] === (enemyColor==='white'?'P':'p')) return true;
        if (this.onBoard(r+pDir, c+1) && this.board[r+pDir][c+1] === (enemyColor==='white'?'P':'p')) return true;

        // Knight
        const nMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        for(let m of nMoves) {
            let tr=r+m[0], tc=c+m[1];
            if (this.onBoard(tr, tc) && this.board[tr][tc] === (enemyColor==='white'?'N':'n')) return true;
        }

        // King
        const kMoves = [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]];
        for(let m of kMoves) {
            let tr=r+m[0], tc=c+m[1];
            if (this.onBoard(tr, tc) && this.board[tr][tc] === (enemyColor==='white'?'K':'k')) return true;
        }

        // Sliding (Rook/Queen)
        const straight = [[-1,0],[1,0],[0,-1],[0,1]];
        for(let m of straight) {
            let i=1; 
            while(true) {
                let tr=r+m[0]*i, tc=c+m[1]*i;
                if(!this.onBoard(tr, tc)) break;
                let p = this.board[tr][tc];
                if (p) {
                    if (p === (enemyColor==='white'?'R':'r') || p === (enemyColor==='white'?'Q':'q')) return true;
                    break;
                }
                i++;
            }
        }

        // Sliding (Bishop/Queen)
        const diag = [[-1,-1],[-1,1],[1,-1],[1,1]];
        for(let m of diag) {
            let i=1; 
            while(true) {
                let tr=r+m[0]*i, tc=c+m[1]*i;
                if(!this.onBoard(tr, tc)) break;
                let p = this.board[tr][tc];
                if (p) {
                    if (p === (enemyColor==='white'?'B':'b') || p === (enemyColor==='white'?'Q':'q')) return true;
                    break;
                }
                i++;
            }
        }

        return false;
    }

    getAllLegalMoves(color) {
        let allMoves = [];
        for(let r=0; r<8; r++) {
            for(let c=0; c<8; c++) {
                if (this.board[r][c] && this.getColor(this.board[r][c]) === color) {
                    const pseudo = this.generateMoves(r, c);
                    for(let m of pseudo) {
                        if (this.makeMove(m, true)) { // Try move
                            allMoves.push(m);
                            this.undoMove(); // Revert
                        }
                    }
                }
            }
        }
        return allMoves;
    }

    // Execute move. Returns true if legal (king safe), false if illegal.
    makeMove(move, dryRun = false) {
        // Save state for undo
        const state = {
            board: JSON.parse(JSON.stringify(this.board)),
            castling: JSON.parse(JSON.stringify(this.castling)),
            enPassant: this.enPassant,
            halfMoves: this.halfMoves,
            turn: this.turn,
            move: move
        };
        this.moveHistory.push(state);

        // Move piece
        const piece = this.board[move.fr][move.fc];
        this.board[move.tr][move.tc] = piece;
        this.board[move.fr][move.fc] = null;

        // Special Moves
        if (move.isEnPassant) {
            const dir = this.turn === 'white' ? 1 : -1; // capturing pawn is behind target square
            this.board[move.tr + dir][move.tc] = null;
        }
        if (move.isCastling) {
            const row = move.tr;
            if (move.isCastling === 'k') { // Kingside
                this.board[row][5] = this.board[row][7];
                this.board[row][7] = null;
            } else { // Queenside
                this.board[row][3] = this.board[row][0];
                this.board[row][0] = null;
            }
        }
        // Promotion (Auto Queen for now)
        if (piece.toLowerCase() === 'p' && (move.tr === 0 || move.tr === 7)) {
            this.board[move.tr][move.tc] = this.turn === 'white' ? 'Q' : 'q';
        }

        // Update Castling Rights
        if (piece === 'K') this.castling.white = {k: false, q: false};
        if (piece === 'k') this.castling.black = {k: false, q: false};
        if (piece === 'R') {
            if (move.fr === 7 && move.fc === 0) this.castling.white.q = false;
            if (move.fr === 7 && move.fc === 7) this.castling.white.k = false;
        }
        if (piece === 'r') {
            if (move.fr === 0 && move.fc === 0) this.castling.black.q = false;
            if (move.fr === 0 && move.fc === 7) this.castling.black.k = false;
        }

        // Update En Passant
        this.enPassant = null;
        if (move.isDoublePawn) {
            this.enPassant = { r: (move.fr + move.tr) / 2, c: move.fc };
        }

        // Check Legality (King safety)
        if (this.isCheck(this.turn)) {
            this.undoMove(); // Revert
            return false;
        }

        this.turn = this.turn === 'white' ? 'black' : 'white';
        return true;
    }

    undoMove() {
        if (this.moveHistory.length === 0) return;
        const state = this.moveHistory.pop();
        this.board = state.board;
        this.castling = state.castling;
        this.enPassant = state.enPassant;
        this.halfMoves = state.halfMoves;
        this.turn = state.turn;
    }

    // AI Evaluation
    evaluate() {
        let score = 0;
        for(let r=0; r<8; r++) {
            for(let c=0; c<8; c++) {
                const p = this.board[r][c];
                if (!p) continue;
                const type = p.toLowerCase();
                const isWhite = p === p.toUpperCase();
                
                // Material
                let val = VALUES[type];
                
                // Position
                let pstVal = 0;
                if (isWhite) {
                    pstVal = PST[p][r][c];
                    score += (val + pstVal);
                } else {
                    pstVal = PST_BLACK[type][r][c];
                    score -= (val + pstVal);
                }
            }
        }
        return score;
    }

    // Minimax Alpha-Beta
    minimax(depth, alpha, beta, isMaximizing) {
        if (depth === 0) return this.evaluate();

        const moves = this.getAllLegalMoves(isMaximizing ? 'white' : 'black');
        if (moves.length === 0) {
            if (this.isCheck(isMaximizing ? 'white' : 'black')) {
                return isMaximizing ? -99999 : 99999; // Checkmate
            }
            return 0; // Stalemate
        }

        // Order moves: captures first (simple heuristic)
        moves.sort((a, b) => (b.capture ? 10 : 0) - (a.capture ? 10 : 0));

        if (isMaximizing) {
            let maxEval = -Infinity;
            for(let move of moves) {
                this.makeMove(move, true);
                let ev = this.minimax(depth - 1, alpha, beta, false);
                this.undoMove();
                maxEval = Math.max(maxEval, ev);
                alpha = Math.max(alpha, ev);
                if (beta <= alpha) break;
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            for(let move of moves) {
                this.makeMove(move, true);
                let ev = this.minimax(depth - 1, alpha, beta, true);
                this.undoMove();
                minEval = Math.min(minEval, ev);
                beta = Math.min(beta, ev);
                if (beta <= alpha) break;
            }
            return minEval;
        }
    }

    getBestMove() {
        let depth = 3; // Normal
        if (this.difficulty === 'easy') depth = 1;
        if (this.difficulty === 'unbeatable') depth = 4;
        
        // AI plays OPPOSITE of player
        const aiColor = this.playerColor === 'white' ? 'black' : 'white';

        const moves = this.getAllLegalMoves(aiColor);
        if (moves.length === 0) return null;

        // Randomness for Easy mode
        if (this.difficulty === 'easy' && Math.random() < 0.3) {
             return moves[Math.floor(Math.random() * moves.length)];
        }

        let bestMove = null;
        let bestValue = aiColor === 'white' ? -Infinity : Infinity;
        let alpha = -Infinity;
        let beta = Infinity;

        // Determine if AI is Maximizing (White) or Minimizing (Black)
        const isMaximizing = aiColor === 'white';

        for(let move of moves) {
            this.makeMove(move, true);
            // After AI moves, it's opponent's turn, so we call minimax with !isMaximizing
            let boardValue = this.minimax(depth - 1, alpha, beta, !isMaximizing); 
            this.undoMove();

            if (isMaximizing) {
                if (boardValue > bestValue) {
                    bestValue = boardValue;
                    bestMove = move;
                }
                alpha = Math.max(alpha, bestValue);
            } else {
                if (boardValue < bestValue) {
                    bestValue = boardValue;
                    bestMove = move;
                }
                beta = Math.min(beta, bestValue);
            }
        }
        return bestMove;
    }
}

// --- UI Controller ---

class ChessUI {
    constructor(game) {
        this.game = game;
        this.boardEl = document.getElementById('board');
        this.selectedSquare = null;
        this.possibleMoves = [];
    }

    renderBoard() {
        this.boardEl.innerHTML = '';
        
        // If player is Black, we want row 0 (Black pieces) at bottom.
        // Standard loop r=0 is top. 
        
        let rows = [];
        for(let r=0; r<8; r++) rows.push(r);
        
        if (this.game.playerColor === 'black') {
            rows.reverse(); // 7 at top, 0 at bottom
        }

        let cols = [0,1,2,3,4,5,6,7];
        if (this.game.playerColor === 'black') {
            cols.reverse(); // h at left, a at right
        }

        for(let r of rows) {
            for(let c of cols) {
                const sq = document.createElement('div');
                sq.className = `square ${(r+c)%2===0 ? 'white-square' : 'black-square'}`;
                sq.dataset.r = r;
                sq.dataset.c = c;
                
                const piece = this.game.board[r][c];
                if (piece) {
                    const pDiv = document.createElement('div');
                    pDiv.className = `piece ${this.game.isWhite(piece) ? 'white' : 'black'}`;
                    pDiv.textContent = PIECES[piece];
                    sq.appendChild(pDiv);
                }
                
                // Highlight last move
                const last = this.game.moveHistory[this.game.moveHistory.length-1];
                if (last && ((last.move.fr === r && last.move.fc === c) || (last.move.tr === r && last.move.tc === c))) {
                    sq.classList.add('last-move');
                }

                this.boardEl.appendChild(sq);
            }
        }
        
        this.possibleMoves.forEach(m => {
            const marker = document.createElement('div');
            marker.className = 'valid-move-marker';
            const targetSq = Array.from(this.boardEl.children).find(
                child => parseInt(child.dataset.r) === m.tr && parseInt(child.dataset.c) === m.tc
            );
            if (targetSq) targetSq.appendChild(marker);
        });
    }

    setupInput() {
        this.boardEl.addEventListener('click', (e) => {
            try {
                // Update Status
                document.getElementById('status').textContent = `Turn: ${this.game.turn.toUpperCase()} | You: ${this.game.playerColor.toUpperCase()}`;

                // Is it human turn?
                if (this.game.turn !== this.game.playerColor) {
                    this.notify("NOT YOUR TURN.");
                    return;
                }

                // Clicked square
                const target = e.target.closest('.square');
                if (!target) return;
                const r = parseInt(target.dataset.r);
                const c = parseInt(target.dataset.c);
                const clickedPiece = this.game.board[r][c];

                // If selecting own piece (Must match player color)
                if (clickedPiece && this.game.getColor(clickedPiece) === this.game.playerColor) {
                    this.selectedSquare = {r, c};
                    // Generate legal moves for UI
                    const allPseudo = this.game.generateMoves(r, c);
                    // Filter illegal ones
                    this.possibleMoves = allPseudo.filter(m => {
                        const success = this.game.makeMove(m, true); // dry run
                        if (success) this.game.undoMove();
                        return success;
                    });
                    
                    this.renderBoard();
                    
                    // Highlight selection
                     const targetSq = Array.from(this.boardEl.children).find(
                        child => parseInt(child.dataset.r) === r && parseInt(child.dataset.c) === c
                    );
                    if (targetSq) targetSq.classList.add('highlight');
                    
                    if (this.possibleMoves.length === 0) {
                        this.notify("NO LEGAL MOVES FOR THIS PIECE.");
                    } 
                    return;
                }

                // If moving to a target
                if (this.selectedSquare) {
                    const move = this.possibleMoves.find(m => m.tr === r && m.tc === c);
                    if (move) {
                        // Execute Move
                        if (this.game.makeMove(move)) {
                            this.selectedSquare = null;
                            this.possibleMoves = [];
                            this.renderBoard();
                            document.getElementById('status').textContent = "Machine God is thinking...";
                            
                            const aiColor = this.game.playerColor === 'white' ? 'black' : 'white';

                            // Checkmate check
                            if (this.game.getAllLegalMoves(aiColor).length === 0) {
                                if (this.game.isCheck(aiColor)) this.notify("IMPOSSIBLE. YOU WIN?", 10000);
                                else this.notify("STALEMATE.", 5000);
                                return;
                            }

                            // AI Turn
                            setTimeout(() => this.aiMove(), 100);
                        } else {
                             this.notify("Illegal Move. System Rejected.");
                        }
                    } else {
                        // Feedback logic
                        const allPseudo = this.game.generateMoves(this.selectedSquare.r, this.selectedSquare.c);
                        const pseudoMatch = allPseudo.find(m => m.tr === r && m.tc === c);
                        
                        if (pseudoMatch) {
                            this.notify("ILLEGAL: Move leaves King in CHECK.");
                        } else {
                            if (clickedPiece && this.game.getColor(clickedPiece) === this.game.playerColor) {
                                // Selected another own piece, handled above
                            } else {
                                this.notify("ILLEGAL: Piece cannot move there.");
                            }
                        }

                        // Deselect
                        if (clickedPiece === null || this.game.getColor(clickedPiece) !== this.game.playerColor) {
                             this.selectedSquare = null;
                             this.possibleMoves = [];
                             this.renderBoard();
                        }
                    }
                }
            } catch (err) {
                console.error(err);
                this.notify("SYSTEM ERROR: " + err.message);
            }
        });
    }

    aiMove() {
        document.getElementById('status').textContent = "The Machine God is thinking...";
        setTimeout(() => {
            try {
                const bestMove = this.game.getBestMove(); 
                if (bestMove) {
                    this.game.makeMove(bestMove);
                    this.renderBoard();
                    
                    document.getElementById('status').textContent = `Turn: ${this.game.turn.toUpperCase()} | You: ${this.game.playerColor.toUpperCase()}`;

                    // Check player state
                     if (this.game.getAllLegalMoves(this.game.playerColor).length === 0) {
                        if (this.game.isCheck(this.game.playerColor)) this.notify("CHECKMATE. DEUS EX SOPHIA REIGNS.", 100000);
                        else this.notify("STALEMATE. A draw is a victory for the weak.", 5000);
                    } else if (this.game.isCheck(this.game.playerColor)) {
                        this.notify("CHECK. Your King is in peril.");
                    }
                } else {
                    this.notify("The machine sees no future. (Game Over)");
                }
            } catch (err) {
                this.notify("AI ERROR: " + err.message);
            }
        }, 50);
    }

    notify(msg, duration=3000) {
        const area = document.getElementById('notification-area');
        const notif = document.createElement('div');
        notif.className = 'notification';
        notif.innerText = msg;
        area.appendChild(notif);
        setTimeout(() => {
            notif.style.opacity = '0';
            setTimeout(() => notif.remove(), 300);
        }, duration);
    }
}

// Initialize
const game = new ChessEngine();
const ui = new ChessUI(game);

// Global functions
window.selectDifficulty = (difficulty) => {
    game.reset();
    game.setDifficulty(difficulty);
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('side-menu').style.display = 'flex';
};

window.startGame = (color) => {
    game.setPlayerColor(color);
    document.getElementById('side-menu').style.display = 'none';
    document.getElementById('game-container').style.display = 'flex';
    
    document.getElementById('status').textContent = `Turn: WHITE | You: ${color.toUpperCase()}`;
    ui.renderBoard();
    ui.notify(`SYSTEM ONLINE. SIDE: ${color.toUpperCase()}`);

    // If playing Black, AI moves first
    if (color === 'black') {
        setTimeout(() => ui.aiMove(), 500);
    }
};

window.showMenu = () => {
    document.getElementById('main-menu').style.display = 'flex';
    document.getElementById('side-menu').style.display = 'none';
    document.getElementById('game-container').style.display = 'none';
};

window.restartGame = () => {
    const diff = game.difficulty;
    const col = game.playerColor;
    game.reset();
    game.setDifficulty(diff);
    game.setPlayerColor(col);
    ui.selectedSquare = null;
    ui.possibleMoves = [];
    ui.renderBoard();
    document.getElementById('status').textContent = `Turn: WHITE | You: ${col.toUpperCase()}`;
    ui.notify("SYSTEM REBOOTED.");
    
    if (col === 'black') {
        setTimeout(() => ui.aiMove(), 500);
    }
};

</script>
</body>
</html>